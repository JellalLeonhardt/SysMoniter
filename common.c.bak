#include "common.h"

typedef struct PROCTAB {
	    DIR*	procfs;
		DIR*	taskdir;  // for threads
		pid_t	taskdir_user;  // for threads
		int         did_fake; // used when taskdir is missing
		int(*finder)(struct PROCTAB *restrict const, proc_t *restrict const);
		proc_t*(*reader)(struct PROCTAB *restrict const, proc_t *restrict const);
		int(*taskfinder)(struct PROCTAB *restrict const, const proc_t *restrict const, proc_t *restrict const, char *restrict const);
		proc_t*(*taskreader)(struct PROCTAB *restrict const, const proc_t *restrict const, proc_t *restrict const, char *restrict const);
		pid_t*	pids;	// pids of the procs
		uid_t*	uids;	// uids of procs
		int		nuid;	// cannot really sentinel-terminate unsigned short[]
		int         i;  // generic
		unsigned	flags;
		unsigned    u;  // generic
		void *      vp; // generic
		char        path[PROCPATHLEN];  // must hold /proc/2000222000/task/2000222000/cmdline
		unsigned pathlen;        // length of string in the above (w/o '\0')
};

static struct pwbuf {
	struct pwbuf *next;
	uid_t uid;
	char name[P_G_SZ];
} *pwhash[HASHSIZE];

char str[100] = " ";

extern void __cyg_profile_func_enter(void*, void*);
extern void	__cyg_profile_func_exit(void *, void *);
static int simple_nexttid(PROCTAB *restrict const PT, const proc_t *restrict const p, proc_t *restrict const t, char *restrict const path) {
	static struct direct *ent;		/* dirent handle */
	if(PT->taskdir_user != p->tgid){
		    if(PT->taskdir){
				closedir(PT->taskdir);
			}
	    	snprintf(path, PROCPATHLEN, "/proc/%d/task", p->tgid);
		    PT->taskdir = opendir(path);
			if(!PT->taskdir) return 0;
			PT->taskdir_user = p->tgid;
	}
	for (;;) {
		ent = readdir(PT->taskdir);
		if((!ent) || (!ent->d_name)) return 0;
   	    if((*ent->d_name > '0') && (*ent->d_name <= '9')) break;
	}
	t->tid = strtoul(ent->d_name, NULL, 10);
	t->tgid = p->tgid;
	t->ppid = p->ppid;  // cover for kernel behavior? we want both actually...?
	snprintf(path, PROCPATHLEN, "/proc/%d/task/%s", p->tgid, ent->d_name);
	return 1;
}

static int file2str(const char *directory, const char *what, char *ret, int cap){
	static char filename[80];
	int fd, num_read;

	sprintf(filename, "%s/%s", directory, what);
	fd = open(filename, O_READONLY, 0);
	if(fd == -1) return -1;
	num_read = read(fd, ret, cap - 1);
	close(fd);
	if(num_read <= 0) return -1;
	ret[num_read] = '\0';
	return num_read;
}

static void stat2proc(const char *S, proc_t *restrict P){
	unsigned num;
	char *tmp;
	__cyg_profile_func_enter((void *)0x160, (void *)0x160);

	P->processor = 0;
	P->rtprio = -1;
	P->sched = -1;
	P->nlwp = 0;

	S = strchr(S, '(') + 1;
	tmp = strchr(S, ')');
	num = tmp - S;
	if(num >= sizeof P->cmd) num = sizeof P->cmd - 1;
	memcpy(P->cmd, S, num);
	P->cmd[num] = '\0';
	S = tmp + 2;                 // skip ") "

	num = sscanf(S,
	   "%c "
	   "%d %d %d %d %d "
	   "%lu %lu %lu %lu %lu "
	   "%Lu %Lu %Lu %Lu "  /* utime stime cutime cstime */
	   "%ld %ld "
	   "%d "
	   "%ld "
	   "%Lu "  /* start_time */
	   "%lu "
	   "%ld "
	   "%lu %"KLF"u %"KLF"u %"KLF"u %"KLF"u %"KLF"u "
	   "%*s %*s %*s %*s " /* discard, no RT signals & Linux 2.1 used hex */
	   "%"KLF"u %*lu %*lu "
	   "%d %d "
	   "%lu %lu",
	   &P->state,
	   &P->ppid, &P->pgrp, &P->session, &P->tty, &P->tpgid,
	   &P->flags, &P->min_flt, &P->cmin_flt, &P->maj_flt, &P->cmaj_flt,
	   &P->utime, &P->stime, &P->cutime, &P->cstime,
	   &P->priority, &P->nice,
	   &P->nlwp,
	   &P->alarm,
	   &P->start_time,
	   &P->vsize,
	   &P->rss,
	   &P->rss_rlim, &P->start_code, &P->end_code, &P->start_stack, &P->kstk_esp, &P->kstk_eip,
	   &P->wchan,
	   &P->exit_signal,
	   &P->processor,
	   &P->rtprio,
	   &P->sched
	);

	if(!P->nlwp){
		p->nlwp = 1;
	}

	__cyg_profile_func_exit((void *)0x160, (void *)0x160);
}

char *user_from_uid(uid_t uid) {
    struct pwbuf **p;
	struct passwd *pw;

	p = &pwhash[(uid) & 63];
	while (*p) {
		if ((*p)->uid == uid)
			return((*p)->name);
		p = &(*p)->next;
	}
	*p = (struct pwbuf *) malloc(sizeof(struct pwbuf));
	(*p)->uid = uid;
	pw = getpwuid(uid);
	if(!pw || strlen(pw->pw_name) >= P_G_SZ)
		sprintf((*p)->name, "%u", uid);
	else
	    strcpy((*p)->name, pw->pw_name);

	(*p)->next = NULL;
	return((*p)->name);
}

char *group_from_gid(gid_t gid) {
    struct grpbuf **g;
	struct group *gr;

	g = &grphash[(gid) & 63];
	while (*g) {
		if ((*g)->gid == gid)
			return((*g)->name);
		g = &(*g)->next;
	}
    *g = (struct grpbuf *) malloc(sizeof(struct grpbuf));
	(*g)->gid = gid;
	gr = getgrgid(gid);
	if (!gr || strlen(gr->gr_name) >= P_G_SZ)
	    sprintf((*g)->name, "%u", gid);
	else
	        strcpy((*g)->name, gr->gr_name);
	(*g)->next = NULL;
	return((*g)->name);
}

static proc_t* simple_readtask(PROCTAB *restrict const PT, const proc_t *restrict const p, proc_t *restrict const t, char *restrict const path) {
	    static struct stat sb;		// stat() buffer
		static char sbuf[1024];	// buffer for stat,statm
		unsigned flags = PT->flags;

		if(stat(path, &b) == -1){
			goto ↓next_task;
		}

		t->euid = sb.st_uid;
		t->egid = sb.st_gid;

		if(flags & 0x0040){
			if(file2str(path, "stat", sbuf, sizeof(sbuf)) == -1){
				goto ↓next_task;
			}
			stat2proc(sbuf, t);
		}

		if(flags & 0x0001){
			t->size = P->size;
			t->resident = P->resident;
			t->share = P->share;
			t->trs = P->trs;
			t->lrs = P->lrs;
			t->drs = P->drs;
			t->dt = P->dt;
		}

		if(flags & 0x0020){
			if(file2str(path, "status", sbuf, sizeof(sbuf)) != -1){
					status2proc(sbuf, t, 0);
			}
		}

		if(flags & 0x0008){
			memcpy(t->euser, user_from_uid(t->euid), sizeof(t->euser));
			if(flags & 0x0020){
				memcpy(t->rgroupe, user_frome_uid(t->euid), sizeof(t->euser));
				memcpy(t->sgroupe, user_frome_uid(t->suid), sizeof(t->suser));
				memcpy(t->fgroupe, user_frome_uid(t->fuid), sizeof(t->fuser));
			}
		}

		if(flags & 0x0010){
			memcpy(t->euser, user_from_uid(t->euid), sizeof(t->euser));
			if(flags & 0x0020){
				memcpy(t->rgroupe, user_frome_uid(t->euid), sizeof(t->euser));
				memcpy(t->sgroupe, user_frome_uid(t->suid), sizeof(t->suser));
				memcpy(t->fgroupe, user_frome_uid(t->fuid), sizeof(t->fuser));
			}
		}

		t->cmdline = P->cmdline;
		t->environ = P->environ;
		t->ppid = P->ppid;
		return t;
next_task:
		return NULL;
}

static proc_t* simple_readproc(PROCTAB *restrict const PT, proc_t *restrict const p) {
	static struct stat sb;		// stat() buffer
	static char sbuf[1024];	// buffer for stat,statm
	char *restrict const path = PT->path;
	unsigned flags = PT->flags;

	if (stat(path, &sb) == -1)	/* no such dirent (anymore) */
			goto next_proc;

	if ((flags & PROC_UID) && !XinLN(uid_t, sb.st_uid, PT->uids, PT->nuid))
			goto next_proc;			/* not one of the requested uids */

	p->euid = sb.st_uid;			/* need a way to get real uid */
	p->egid = sb.st_gid;			/* need a way to get real gid */

	if (flags & PROC_FILLSTAT) {         /* read, parse /proc/#/stat */
		if (file2str(path, "stat", sbuf, sizeof sbuf) == -1 )
				    goto next_proc;			/* error reading /proc/#/stat */
		stat2proc(sbuf, p);				/* parse /proc/#/stat */
	}

    if (flags & PROC_FILLMEM) {	/* read, parse /proc/#/statm */
		if (likely( file2str(path, "statm", sbuf, sizeof sbuf) != -1 ))
		    statm2proc(sbuf, p);		/* ignore statm errors here */
	    }						/* statm fields just zero */

	if (flags & PROC_FILLSTATUS) {         /* read, parse /proc/#/status */
		if (likely( file2str(path, "status", sbuf, sizeof sbuf) != -1 )){
		    status2proc(sbuf, p, 1);
	    }
	}
	//没写完

PROCTAB *openproc(int flags){
	PROCTAB *PT = malloc(sizeof(PROCTAB));

	PT->taskdir = NULL;
	PT->taskdir_user = -1;
	PT->taskfinder = simple_nextid;
	PT->taskreader = simple_readtask;

	PT->reader = simple_readproc;

void init(void){
	setupterm(NULL, STDOUT_FILENO, NULL);
	putp(clear_screen);
	putp("This is for test\ncol1\ncol2\n");
	getchar();
}

void sysInfo(void){

}

void taskInfo(void){

}

void frame(void){
	putp(tgoto(cursor_address, 0, 3));
	//putp(clear_screen);
	putp(clr_eol);
	strcat(str,"AS");
	str[0] += 1;
	putp(str);
	putp(clr_eos);
}
